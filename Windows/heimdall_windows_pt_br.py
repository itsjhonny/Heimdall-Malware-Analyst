#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import requests
import hashlib
import sys
import subprocess, platform

from os import path,system
from json import JSONDecodeError
from time import sleep

#funcao que verifica se o usuario quer fazer novo scan
def novo_scan():
	a = input("\nDeseja escanear um novo arquivo ou site? s/n \n")

	if a == "s" or a == "S":
		if platform.system()=="Windows":
			subprocess.Popen("cls", shell=True).communicate()
		else:
			print("\033c", end="")
		__name__


	elif a == "n" or a == "n":		
		exit(0)

	else:
		print("Comando Inválido")
		novo_scan()




#type = 1 para site e 2 para arquivos
def result(_type,response):

	#pega a data que o binario foi scaneado 
	print("\nData: %s \n" %(response.json()['scan_date']))

	#pega numero de positivos
	positives = response.json()['positives']

	
	print("Detectados: %s / %s \n\n" %(positives,response.json()['total']))
	print("Anti-Virus scan utilizados: \n")



	#lista o resultado
	resp_scan = response.json()['scans']
	for x in resp_scan:
		malware_detected = resp_scan[x]['detected']

		
		if not malware_detected: #se nao tiver malware
		  
		  malware_detected = "Limpo"

		  if _type == 1: #json de resposta para website nao vem com a versão do scan utilizado :( por isso precisa desse if
		  	 print("%s\n\nResultado: %s" %(x,malware_detected))

		  else:
		  	print("%s\n\nVersao: %s \nResultado: %s" %(x,resp_scan[x]['version'],malware_detected))



		else:
		  #adiciona o tipo do malware
		  malware_detected = "Arquivo Malicioso"

		  if _type == 1:
		  	print("%s\n\nResultado: %s\nTipo do Malware: %s" %(x,malware_detected,a[x]['result']))

		  else:
			  
			  print("%s\n\nVersao: %s \nResultado: %s\nTipo do Malware: %s" %(x,resp_scan[x]['version'],malware_detected,resp_scan[x]['result']))


		print("--------------------------------------------------------")


	#chama funcao que verifica se o usuario quer fazer novo scan
	novo_scan()




def is_website(_input):

	url = "https://www.virustotal.com/vtapi/v2/url/"
	apikey = '4e3202fdbe953d628f650229af5b3eb49cd46b2d3bfe5546ae3c5fa48b554e0c'


	#funcao para checar de 20 em 20 se o website foi scaneado		
	def check():
		print("Por favor aguarde")
		sleep(20)

		url = 'https://www.virustotal.com/vtapi/v2/url/report'

		params = {'apikey': apikey, 'resource':_input}

		try:
			response = requests.get(url, params=params)

			if response.json()['response_code'] == 1:
				result(1,response)

			else:
				check()


		except JSONDecodeError:
			check()


	#funcao que envia o site para scan
	def send_website():
		print("Site não encontrado no banco de dados\nSerá enviando para analise")
				
		
		params = {'apikey': apikey, 'url':_input}
		
		try:
			response = requests.post(url + "scan", data=params)
			if response.json()['verbose_msg'] != "Scan request successfully queued, come back later for the report":
				print("Falha ao enviar o site\nNova tentativa em 5 segundos\nPor favor aguarde")
				sleep(5)
				send_website()

			else:
				print("\nSite enviado com sucesso. \nSerá analisado em breve\nO tempo estimado é de 20 segundos")
				check()

		except JSONDecodeError:
				print("Falha ao enviar o site\nNova tentativa em 5 segundos\nPor favor aguarde")
				sleep(5)
				send_website()
				

		print("\nSite enviado com sucesso para análise.\nO tempo estimado é de 20 segundos")	
	

	#verifica se o site está no banco de dados
	def check_in_database():
		params = {'apikey': apikey, 'resource':_input}

		try:
			response = requests.post(url + "report", data=params)
			#se o code for 1 e porque o banco de dados possui a assinatura e vai para funcao de exibir o resultado. Caso seja 0 ele envia o binario
			if response.json()['response_code'] == 1:
				result(1,response)

			else:
				send_website() #envia o site para o scan

		except JSONDecodeError:
			print("Falha ao checar website no banco de dados\nNova tentativa em 5 segundos\nPor favor aguarde")
			sleep(5)
			check_in_database()	
		
	check_in_database()

		


def is_file(_input):
	url = 'https://www.virustotal.com/vtapi/v2/file/'
	apikey = '4e3202fdbe953d628f650229af5b3eb49cd46b2d3bfe5546ae3c5fa48b554e0c'
	hash_md5 = hashlib.md5()

	#funcao para checar de 60 em 60 segundos se o arquivo foi scaneado
	def check():		
		print("Por favor aguarde")
		sleep(60)
		
		params = {'apikey': apikey, 'resource':str(hash_md5.hexdigest())}

		try:
			response = requests.get(url + "report", params=params)

			if response.json()['response_code'] == 1:
				result(2,response)

			else:
				print("Arquivo ainda em analise")
				check()


		except JSONDecodeError:
			check()

	
	#envia o binario para analise
	def send_file():
		print("Arquivo não encontrado no banco de dados\nSerá enviando para analise")

		
		params = {'apikey': apikey}

		with open(_input, "rb") as f:
			files = {'file': (str(hash_md5), f.read())}

		#variavel que faz e pega a resposta
		try:
			response = requests.post(url + "scan", files=files, params=params)
			if response.json()['verbose_msg'] != "Scan request successfully queued, come back later for the report":
				print("Falha ao enviar o arquivo\nNova tentativa em 5 segundos\nPor favor aguarde")
				sleep(5)
				send_file()

			else:
				print("\nArquivo enviado com sucesso. \nSerá analisado em breve\nO tempo estimado é de 2 minutos")
				check()


		except JSONDecodeError:
			print("Falha ao enviar o arquivo\nNova tentativa em 5 segundos\nPor favor aguarde")
			sleep(5)
			send_file()


	#funcao que checa se o binario ja esta no banco de dados
	def check_in_database():
		#abre o binario e pega sua hash_md5 depois fecha
		with open(_input, "rb") as f:
			for x in iter(lambda: f.read(), b""):
			  hash_md5.update(x)


		params = {'apikey': apikey, 'resource': hash_md5.hexdigest()}

		try:
			response = requests.get(url+"report", params=params)
			#se o code for 1 e porque o banco de dados possui a assinatura e vai para funcao de exibir o resultado. Caso seja 0 ele envia o binario
			if response.json()['response_code'] == 1:
				result(2,response)

			else:
				send_file()


		except JSONDecodeError:
			print("Falha ao checar arquivo no banco de dados\nNova tentativa em 5 segundos\nPor favor aguarde")
			sleep(5)
			check_in_database()
			
	check_in_database()




def art():
	print(""" 
      _,.
    ,` -.)
   ( _/-\\-._
  /,|`--._,-^|            ,
  \_| |`-._/||          ,'|
    |  `-,  /|         /  /
    |     || |        /  /
     `r-._||/   __   /  /
 __,-<_     )`-/  `./  /
'  \   `---'   \   /  /
    |           |./  /
    /           //  /
\_/' \         |/  /
 |    |   _,^-'/  /
 |    , ``  (\/  /
  \,.->._    \  /
  (  /   `-._//^`
   `Y-.____(__}
    |     {__)
          ()

HEIMDALL MALWARES SCANNER -- João Pedro Guimaraes

https://www.linkedin.com/in/johnpguimaraes/
https://github.com/jpvibes
https://jpguimaraes.com

	""")
	return


def main():
	art()
	_input = input("Insira um arquivo ou um site e aperte enter: ").replace("'","").replace(" ","")

	#verifica entradas do arquivo
	if len(_input) <= 0:
		print("\nPor favor insira um arquivo ou um site\n")
		sleep(2)
		main()



	#sai do scan caso seja escrito exit
	elif _input == "exit":
		sys.exit()

	else:

		#se for um website
		if "http://" in _input or "https://" in _input:

			if requests.head(_input).status_code != 404:
				is_website(_input)

			else:
				print("Falha ao se conectar ao site. Erro %s\nPor favor, verifique se o endereço do site está correto e tente novamente" %(requests.head(_input).status_code))
				sleep(2)
				main()
			


		#se for um binario
		else:

			#verifica o path do binario
			if not path.isfile(_input):
				print("\nArquivo nao encontrado\n")
				sleep(2)
				main()
			

			elif path.getsize(_input) < 133169152:
				is_file(_input)

			else:
				print("Arquivo muito grande para ser analisado")
				p = ['B', 'KB', 'MB', 'GB', 'TB', 'PB']

				def get_size(x):
				    i = 0
				    while x >= 1024 and i < len(p)-1:
				        x /= 1024.
				        i += 1
				    f = ('%.2f' % x).rstrip('0').rstrip('.')

				    print("Seu arquivo possui %s %s e o limite é de 127 MB\n\n" %(f, p[i]))
				    sleep(2)
				    main()

				get_size(path.getsize(_input))


				    
				


		#volta pra main
		main()

	



if __name__ == '__main__':
	
	if platform.system()=="Windows":
		subprocess.Popen("cls", shell=True).communicate()
	else:
		print("\033c", end="")
	main()
